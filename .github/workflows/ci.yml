---
name: CI

on:
  push:
    branches: [main, develop]
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - '.gitignore'
      - 'LICENSE'
  pull_request:
    branches: [main, develop]
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - '.gitignore'
      - 'LICENSE'
  workflow_dispatch:

env:
  GO_VERSION: '1.22'

permissions:
  contents: read
  pull-requests: write
  checks: write

jobs:
  changes:
    name: Detect Changes
    runs-on: ubuntu-latest
    outputs:
      go: ${{ steps.changes.outputs.go }}
      actions: ${{ steps.changes.outputs.actions }}
      scripts: ${{ steps.changes.outputs.scripts }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Detect changes
        uses: dorny/paths-filter@v3
        id: changes
        with:
          filters: |
            go:
              - '**/*.go'
              - 'go.mod'
              - 'go.sum'
              - 'Makefile'
            actions:
              - '.github/workflows/**'
              - 'action.yml'
            scripts:
              - 'scripts/**'

  lint:
    name: Lint Code
    runs-on: ubuntu-latest
    needs: changes
    if: needs.changes.outputs.go == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Run golangci-lint
        uses: golangci/golangci-lint-action@v4
        with:
          version: latest
          args: --timeout=5m --verbose

      - name: Check go mod tidy
        run: |
          go mod tidy
          if ! git diff --exit-code go.mod go.sum; then
            echo "Error: go.mod or go.sum is not tidy"
            echo "Run 'go mod tidy' to fix this"
            exit 1
          fi

      - name: Check formatting
        run: |
          if [ "$(gofmt -s -l . | wc -l)" -gt 0 ]; then
            echo "Error: Code is not formatted"
            echo "Run 'gofmt -s -w .' to fix formatting issues:"
            gofmt -s -l .
            exit 1
          fi

  test:
    name: Test
    runs-on: ${{ matrix.os }}
    needs: changes
    if: needs.changes.outputs.go == 'true'
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        go-version: ['1.21', '1.22']
      fail-fast: false
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ matrix.go-version }}
          cache: true

      - name: Download dependencies
        run: go mod download

      - name: Run tests
        shell: bash
        run: |
          go test -v -race -coverprofile=coverage.out ./...

      - name: Generate coverage report
        if: matrix.os == 'ubuntu-latest' && matrix.go-version == env.GO_VERSION
        run: |
          go tool cover -html=coverage.out -o coverage.html
          go tool cover -func=coverage.out

      - name: Upload coverage to Codecov
        if: matrix.os == 'ubuntu-latest' && matrix.go-version == env.GO_VERSION
        uses: codecov/codecov-action@v4
        with:
          file: ./coverage.out
          flags: unittests
          name: codecov-umbrella

      - name: Upload coverage artifacts
        if: matrix.os == 'ubuntu-latest' && matrix.go-version == env.GO_VERSION
        uses: actions/upload-artifact@v4
        with:
          name: coverage-reports
          path: |
            coverage.out
            coverage.html

  build:
    name: Build
    runs-on: ${{ matrix.os }}
    needs: changes
    if: needs.changes.outputs.go == 'true'
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
      fail-fast: false
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Download dependencies
        run: go mod download

      - name: Build binary
        run: |
          make build

      - name: Test binary execution
        shell: bash
        run: |
          if [ "${{ matrix.os }}" = "windows-latest" ]; then
            BINARY="bin/syncwright.exe"
          else
            BINARY="bin/syncwright"
          fi

          if [ ! -f "$BINARY" ]; then
            echo "Error: Binary not found at $BINARY"
            ls -la bin/
            exit 1
          fi

          # Test basic command execution
          "$BINARY" --help || echo "Help command completed with exit code $?"
          "$BINARY" --version || echo "Version command completed with exit code $?"

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: binary-${{ matrix.os }}
          path: bin/

  test-cli-commands:
    name: Test CLI Commands
    runs-on: ubuntu-latest
    needs: [changes, build]
    if: needs.changes.outputs.go == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Build binary
        run: make build

      - name: Set up test environment
        run: |
          # Create a test git repository
          git config --global user.name "CI Test"
          git config --global user.email "ci@example.com"
          git config --global init.defaultBranch main

          mkdir test-repo
          cd test-repo
          git init

          # Create initial file
          echo "initial content" > test.txt
          git add test.txt
          git commit -m "Initial commit"

          # Create conflict scenario
          git checkout -b feature
          echo "feature change" > test.txt
          git add test.txt
          git commit -m "Feature change"

          git checkout main
          echo "main change" > test.txt
          git add test.txt
          git commit -m "Main change"

      - name: Test validate command
        run: |
          cd test-repo
          ../bin/syncwright validate --verbose || echo "Validate command completed"

      - name: Test detect command
        run: |
          cd test-repo
          # Try to merge to create conflicts
          git merge feature || true
          ../bin/syncwright detect --format json || echo "Detect command completed"

      - name: Test format command
        run: |
          cd test-repo
          ../bin/syncwright format --check || echo "Format command completed"

      - name: Test version command
        run: |
          ./bin/syncwright --version

      - name: Test help command
        run: |
          ./bin/syncwright --help
          ./bin/syncwright validate --help
          ./bin/syncwright detect --help
          ./bin/syncwright format --help

  validate-actions:
    name: Validate GitHub Actions
    runs-on: ubuntu-latest
    needs: changes
    if: needs.changes.outputs.actions == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install yamllint
        run: |
          pip3 install yamllint

      - name: Validate YAML with yamllint
        run: |
          # Create yamllint config to be less strict for GitHub Actions
          cat > .yamllint.yml << 'EOF'
          extends: default
          rules:
            line-length:
              max: 120
            indentation:
              spaces: 2
            comments:
              min-spaces-from-content: 1
            comments-indentation: disable
            truthy:
              allowed-values: ['true', 'false', 'on', 'off', 'yes', 'no']
          EOF

          echo "Validating YAML files with yamllint..."
          yamllint action.yml .github/workflows/

      - name: Validate action.yml syntax (Python fallback)
        run: |
          # Additional Python-based validation for action.yml
          python3 << 'PYTHON_SCRIPT'
          import yaml
          import sys

          try:
              with open('action.yml', 'r') as f:
                  data = yaml.safe_load(f)
              print('âœ… action.yml syntax is valid')

              # Check required fields
              required_fields = ['name', 'description', 'runs']
              for field in required_fields:
                  if field not in data:
                      print(f'âŒ Missing required field: {field}')
                      sys.exit(1)
                  else:
                      print(f'âœ… Found required field: {field}')

          except yaml.YAMLError as e:
              print(f'âŒ action.yml syntax error: {e}')
              sys.exit(1)
          except FileNotFoundError:
              print('âŒ action.yml file not found')
              sys.exit(1)
          PYTHON_SCRIPT

      - name: Validate workflow syntax (Python fallback)
        run: |
          # Additional Python-based validation for workflow files
          python3 << 'PYTHON_SCRIPT'
          import yaml
          import sys
          import glob

          workflows = glob.glob('.github/workflows/*.yml')
          errors = []

          for workflow in workflows:
              print(f"Validating {workflow}")
              try:
                  with open(workflow, 'r') as f:
                      data = yaml.safe_load(f)
                  print(f'âœ… {workflow} syntax is valid')

                  # Basic workflow structure validation
                  if 'on' not in data:
                      print(f'âš ï¸  {workflow} missing "on" trigger specification')
                  if 'jobs' not in data:
                      print(f'âŒ {workflow} missing "jobs" section')
                      errors.append(f'{workflow} missing jobs section')

              except yaml.YAMLError as e:
                  error_msg = f'âŒ {workflow} syntax error: {e}'
                  print(error_msg)
                  errors.append(error_msg)

          if errors:
              print("\nValidation failed with errors:")
              for error in errors:
                  print(error)
              sys.exit(1)
          else:
              print("\nâœ… All workflow files have valid syntax")
          PYTHON_SCRIPT

      - name: Check action metadata
        run: |
          # Check required fields for GitHub Actions
          required_fields=("name" "description" "runs")

          for field in "${required_fields[@]}"; do
            if ! grep -q "^${field}:" action.yml; then
              echo "âŒ Missing required field: $field"
              exit 1
            else
              echo "âœ… Found required field: $field"
            fi
          done

      - name: Validate composite action
        run: |
          # Check that referenced files exist
          if grep -q "github.action_path" action.yml; then
            echo "âœ… Action uses github.action_path correctly"
          fi

          # Check shell specifications
          if ! grep -q "shell: bash" action.yml; then
            echo "âŒ Missing shell specification in composite action"
            exit 1
          fi

  validate-scripts:
    name: Validate Scripts
    runs-on: ubuntu-latest
    needs: changes
    if: needs.changes.outputs.scripts == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install shellcheck
        run: |
          sudo apt-get update
          sudo apt-get install -y shellcheck

      - name: Validate shell scripts
        run: |
          find scripts/ -name "*.sh" -type f | while read -r script; do
            echo "Checking $script"
            shellcheck "$script"
          done

      - name: Test script execution
        run: |
          # Test install script with dry run simulation
          chmod +x scripts/install.sh

          # Test help output
          scripts/install.sh --help

  integration-test:
    name: Integration Test
    runs-on: ubuntu-latest
    needs: [build, validate-actions]
    if: needs.changes.outputs.go == 'true' || needs.changes.outputs.actions == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up test repository
        run: |
          git config --global user.name "Integration Test"
          git config --global user.email "integration@example.com"

          # Create a complex test scenario
          mkdir integration-test
          cd integration-test
          git init

          # Create multiple files with different content
          echo "shared content" > shared.txt
          echo "file1 content" > file1.txt
          echo "file2 content" > file2.txt
          git add .
          git commit -m "Initial commit"

          # Create feature branch
          git checkout -b feature
          echo "shared content modified in feature" > shared.txt
          echo "file1 modified in feature" > file1.txt
          echo "new feature file" > feature.txt
          git add .
          git commit -m "Feature changes"

          # Switch back and make conflicting changes
          git checkout main
          echo "shared content modified in main" > shared.txt
          echo "file1 modified in main" > file1.txt
          echo "new main file" > main.txt
          git add .
          git commit -m "Main changes"

      - name: Test action with integration scenario
        uses: ./
        with:
          run_validation: 'true'
          max_tokens: '5000'
          merge_failed: 'false'
        continue-on-error: true

      - name: Verify integration test results
        run: |
          echo "Integration test completed"
          if [ -f "./syncwright" ]; then
            echo "âœ… Syncwright binary installed successfully"
          else
            echo "âŒ Syncwright binary not found"
            exit 1
          fi

  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    needs: changes
    if: needs.changes.outputs.go == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Install gosec
        run: |
          go install github.com/securecodewarrior/gosec/v2/cmd/gosec@latest

      - name: Run Gosec Security Scanner
        run: |
          gosec -fmt sarif -out gosec.sarif ./...
        continue-on-error: true

      - name: Upload SARIF file
        if: hashFiles('gosec.sarif') != ''
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: gosec.sarif

  performance-test:
    name: Performance Test
    runs-on: ubuntu-latest
    needs: [changes, build]
    if: needs.changes.outputs.go == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Build binary
        run: make build

      - name: Run performance benchmarks
        run: |
          # Run Go benchmarks
          go test -bench=. -benchmem ./... > benchmark.txt
          cat benchmark.txt

      - name: Upload performance results
        uses: actions/upload-artifact@v4
        with:
          name: performance-results
          path: benchmark.txt

  summary:
    name: CI Summary
    runs-on: ubuntu-latest
    needs: [changes, lint, test, build, test-cli-commands, validate-actions,
            validate-scripts, integration-test, security-scan, performance-test]
    if: always()
    steps:
      - name: Generate CI summary
        run: |
          echo "## ðŸ” CI Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Check which jobs ran based on changes
          if [ "${{ needs.changes.outputs.go }}" = "true" ]; then
            echo "### Go Code Changes Detected" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| Job | Status |" >> $GITHUB_STEP_SUMMARY
            echo "|-----|--------|" >> $GITHUB_STEP_SUMMARY
            echo "| Lint | ${{ needs.lint.result }} |" >> $GITHUB_STEP_SUMMARY
            echo "| Test | ${{ needs.test.result }} |" >> $GITHUB_STEP_SUMMARY
            echo "| Build | ${{ needs.build.result }} |" >> $GITHUB_STEP_SUMMARY
            echo "| CLI Commands Test | ${{ needs.test-cli-commands.result }} |" >> $GITHUB_STEP_SUMMARY
            echo "| Security Scan | ${{ needs.security-scan.result }} |" >> $GITHUB_STEP_SUMMARY
            echo "| Performance Test | ${{ needs.performance-test.result }} |" >> $GITHUB_STEP_SUMMARY
          fi

          if [ "${{ needs.changes.outputs.actions }}" = "true" ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### GitHub Actions Changes Detected" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| Job | Status |" >> $GITHUB_STEP_SUMMARY
            echo "|-----|--------|" >> $GITHUB_STEP_SUMMARY
            echo "| Validate Actions | ${{ needs.validate-actions.result }} |" >> $GITHUB_STEP_SUMMARY
          fi

          if [ "${{ needs.changes.outputs.scripts }}" = "true" ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### Script Changes Detected" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| Job | Status |" >> $GITHUB_STEP_SUMMARY
            echo "|-----|--------|" >> $GITHUB_STEP_SUMMARY
            echo "| Validate Scripts | ${{ needs.validate-scripts.result }} |" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Integration Test | ${{ needs.integration-test.result }} |" >> $GITHUB_STEP_SUMMARY

          # Overall status
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ needs.lint.result }}" != "failure" ] && \
             [ "${{ needs.test.result }}" != "failure" ] && \
             [ "${{ needs.build.result }}" != "failure" ]; then
            echo "âœ… **CI passed successfully**" >> $GITHUB_STEP_SUMMARY
          else
            echo "âŒ **CI failed - check job details above**" >> $GITHUB_STEP_SUMMARY
          fi
